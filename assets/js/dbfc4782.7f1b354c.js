"use strict";(self.webpackChunkautocode_2_github_io=self.webpackChunkautocode_2_github_io||[]).push([[8749],{1895:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"new-sonnet","metadata":{"permalink":"/blog/new-sonnet","source":"@site/blog/2024-10-24-new-sonnet.mdx","title":"Testing the new Sonnet","description":"Anthropic have just released their latest model, confusing still called sonnet-3.5 (or technically claude-3-5-sonnet-20241022), we\'ll call it new sonnet.","date":"2024-10-24T00:00:00.000Z","tags":[],"readingTime":1.055,"hasTruncateMarker":true,"authors":[{"name":"Gareth Andrew","title":"Chief Auto Coder","url":"https://github.com/autocode2","imageURL":"https://github.com/autocode2.png","key":"gingerhendrix","page":null}],"frontMatter":{"slug":"new-sonnet","title":"Testing the new Sonnet","authors":["gingerhendrix"],"tags":[]},"unlisted":false,"nextItem":{"title":"Understanding LangGraph Types","permalink":"/blog/understanding-langgraph-types"}},"content":"Anthropic have just released their latest model, confusing still called sonnet-3.5 (or technically `claude-3-5-sonnet-20241022`), we\'ll call it new sonnet.\\nThis model seems to have had quite a major update to it\'s coding abilities, so lets see how it compares on our react-todo apps.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Basic Todo\\n\\nSee [Introducing React Todo](/blog/introducing-react-todo) for the prompt.\\n\\n![Old Sonnet vs New Sonnet](./2024-10-24/basic-side-by-side.png)\\n\\n##### Old Sonnet\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/42a36d5dd5c064ad0b7af480d4d6f4c70ae0e715)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/typescript_nextjs_shadcn/sonnet)\\n\\n##### New Sonnet\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/746b5aaf3744f546ff0c8c7a992cda5d2d6cbaf4)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-10-24-new-sonnet/basic/sonnet-v2)\\n\\nA nice design improvement. New sonnet has also generated simpler code with a single file implementation.\\n\\n## Fully Featured Todo\\n\\nSee [Todo with more features](/blog/todo-with-more-features) for the prompt.\\n\\n![Old Sonnet vs New Sonnet](./2024-10-24/fully-featured-side-by-side.png)\\n\\n##### New Sonnet\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/ef91a71575464dae7d2b64dcd141fe90d6e6db41)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-10-24-new-sonnet/fully-featured/sonnet-v2)\\n\\n##### Old Sonnet\\n\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-14-todo-with-more-features/typescript_nextjs_shadcn/sonnet)\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/0057b0233f4042afebd4de82838a7d61552d13e1)\\n\\nAgain a significant design improvement. Also the new sonnet doesn\'t introduce the same type error we had with old sonnet.  The code is fairly closely matched, though the new sonnet extracts the sort and filter logic out into `lib/todoUtils.ts`.\\n\\n\\n# Conclusion\\n\\nFairly terrible UI has been the hallmark of the all the models tested so far. The new sonnet is a welcome improvement in this regard, and obviously for Anthropic it makes artifacts a lot more usable."},{"id":"understanding-langgraph-types","metadata":{"permalink":"/blog/understanding-langgraph-types","source":"@site/blog/2024-10-15-understanding-langgraph-types.mdx","title":"Understanding LangGraph Types","description":"I often run into difficulties trying to build generic apis on top of LangGraph. The types are quite complex so I needed a reference.","date":"2024-10-15T00:00:00.000Z","tags":[],"readingTime":4.95,"hasTruncateMarker":true,"authors":[{"name":"Gareth Andrew","title":"Chief Auto Coder","url":"https://github.com/autocode2","imageURL":"https://github.com/autocode2.png","key":"gingerhendrix","page":null}],"frontMatter":{"slug":"understanding-langgraph-types","title":"Understanding LangGraph Types","authors":["gingerhendrix"],"tags":[]},"unlisted":false,"prevItem":{"title":"Testing the new Sonnet","permalink":"/blog/new-sonnet"},"nextItem":{"title":"Todo with more features","permalink":"/blog/todo-with-more-features"}},"content":"I often run into difficulties trying to build generic apis on top of LangGraph. The types are quite complex so I needed a reference.\\n\\n\x3c!-- truncate --\x3e\\n\\n## 1. StateDefinition and Channels: The Building Blocks of State\\n\\nAt the heart of LangGraph\'s state management is the `StateDefinition`. This is an object that defines the structure of your application\'s state, where each key represents a piece of state, and the value is a *channel* that determines how that state is\\nupdated.\\n\\nA channel in LangGraph is an instance of a class that extends `BaseChannel`. Different channel types provide different behaviors for updating state. Let\'s look at some common channel types:\\n\\n```typescript\\nimport { LastValue, Topic, BinaryOperatorAggregate, EphemeralValue } from \\"@langchain/langgraph/channels\\";\\n\\n// Define our state structure\\ninterface Ticket {\\n    id: string;\\n    customer: string;\\n    issue: string;\\n    status: \'open\' | \'in_progress\' | \'closed\';\\n}\\n\\n// Create our state definition with explicit channels\\nconst TicketSystemState = {\\n    currentTicket: new LastValue<Ticket>(),\\n    allTickets: new Topic<Ticket>({ accumulate: true }),\\n    ticketCounts: new BinaryOperatorAggregate<Record<Ticket[\'status\'], number>, Ticket>(\\n      (current, newTicket) => ({\\n        ...current,\\n        [newTicket.status]: (current[newTicket.status] || 0) + 1,\\n      }),\\n      () => ({ open: 0, in_progress: 0, closed: 0 })\\n    ),\\n    lastAction: new LastValue<string>(),\\n    tempData: new EphemeralValue<any>(),\\n};\\n```\\n\\nIn this example:\\n- `LastValue` always stores the most recent value.\\n- `Topic` accumulates values over time.\\n- `BinaryOperatorAggregate` allows custom reduction logic.\\n- `EphemeralValue` stores temporary data that\'s cleared after each step.\\n\\nEach channel type provides different behavior for how state is updated and maintained throughout the execution of your graph.\\n\\n## 2. Annotation.Root: Syntactic Sugar for State Definition\\n\\nWhile explicitly defining channels gives you fine-grained control, LangGraph provides a more concise way to define state using `Annotation.Root`. This approach uses type inference and default behaviors to simplify your state definition:\\n\\n```typescript\\nimport { Annotation } from \\"@langchain/langgraph\\";\\n\\nconst TicketSystemState = Annotation.Root({\\n    currentTicket: Annotation<Ticket>(),\\n    allTickets: Annotation<Ticket[]>({\\n      reducer: (current, newTickets) => [...current, ...newTickets],\\n      default: () => [],\\n    }),\\n    ticketCounts: Annotation<Record<Ticket[\'status\'], number>>({\\n      reducer: (current, newTicket: Ticket) => ({\\n        ...current,\\n        [newTicket.status]: (current[newTicket.status] || 0) + 1,\\n      }),\\n      default: () => ({ open: 0, in_progress: 0, closed: 0 }),\\n    }),\\n    lastAction: Annotation<string>(),\\n    tempData: Annotation<any>(),\\n});\\n```\\n\\nThis approach is more concise and easier to read.\\n\\n## 3. Building a StateGraph: Understanding the State Types\\n\\nLet\'s create a StateGraph using our TicketSystemState and examine its type:\\n\\n```typescript\\nimport { StateGraph, type StateType, type UpdateType } from \\"@langchain/langgraph\\";\\n\\nconst ticketSystem = new StateGraph(TicketSystemState);\\n```\\n\\nThe type of `ticketSystem` is quite complex due to TypeScript\'s type inference. If we were to write it out explicitly, it would look something like this:\\n\\n```typescript\\nconst ticketSystem: StateGraph<\\ntypeof TicketSystemState,\\nStateType<typeof TicketSystemState>,\\nUpdateType<typeof TicketSystemState>,\\nstring,\\ntypeof TicketSystemState,\\ntypeof TicketSystemState\\n>;\\n```\\n\\nLet\'s break down these type parameters:\\n\\n1. `typeof TicketSystemState`: This is the state definition.\\n2. `StateType<typeof TicketSystemState>`: This represents the actual state shape, derived from the state definition.\\n3. `UpdateType<typeof TicketSystemState>`: This represents the shape of partial updates to the state.\\n4. `string`: This is the default type for node names.\\n5. `typeof TicketSystemState`: This is used for both the input and output state definitions, which are the same as our main state in this case.\\n\\nNow, when we add nodes to our StateGraph, the types of the state and updates are inferred from our state definition:\\n\\n```typescript\\nticketSystem.addNode(\\"receiveTicket\\", (state) => {\\n// \'state\' is inferred to be StateType<typeof TicketSystemState>\\nconst newTicket: Ticket = {\\n  id: `ticket_${Date.now()}`,\\n  customer: \\"John Doe\\",\\n  issue: \\"Cannot login\\",\\n  status: \\"open\\",\\n};\\n// The return type is inferred to be UpdateType<typeof TicketSystemState>\\nreturn {\\n  currentTicket: newTicket,\\n  allTickets: [newTicket],\\n  ticketCounts: newTicket,\\n  lastAction: \\"Received new ticket\\",\\n  tempData: { receivedAt: new Date() },\\n};\\n});\\n```\\n\\nIn this node function:\\n- The `state` parameter is of type `StateType<typeof TicketSystemState>`, which includes all the fields we defined in our state.\\n- The return value is of type `UpdateType<typeof TicketSystemState>`, which is a partial update to our state.\\n\\n## 4. Type-Safe Node Names in StateGraph\\n\\nIn addition to type-checking the state, StateGraph also provides type safety for node names. As we add nodes to our graph, TypeScript updates the union type of node names in the StateGraph type. Let\'s see how this works:\\n\\n```typescript\\nticketSystem\\n.addNode(\\"receiveTicket\\", (state) => {\\n  // Node logic here...\\n  return { /* ... */ };\\n})\\n.addNode(\\"processTicket\\", (state) => {\\n  // Node logic here...\\n  return { /* ... */ };\\n})\\n.addNode(\\"closeTicket\\", (state) => {\\n  // Node logic here...\\n  return { /* ... */ };\\n});\\n```\\n\\nAfter adding these nodes, the type of `ticketSystem` includes the literal types \\"receiveTicket\\", \\"processTicket\\", and \\"closeTicket\\" in its node name union. The full type now looks like this:\\n\\n```typescript\\nconst ticketSystem: StateGraph<\\ntypeof TicketSystemState,\\nStateType<typeof TicketSystemState>,\\nUpdateType<typeof TicketSystemState>,\\n\\"receiveTicket\\" | \\"processTicket\\" | \\"closeTicket\\",\\ntypeof TicketSystemState,\\ntypeof TicketSystemState\\n>;\\n```\\n\\nThis type-checking becomes particularly useful when we add edges:\\n\\n```typescript\\nticketSystem\\n.addEdge(\\"receiveTicket\\", \\"processTicket\\")\\n.addEdge(\\"processTicket\\", \\"closeTicket\\");\\n```\\n\\nTypeScript will ensure that we\'re only using node names that we\'ve actually defined. If we try to add an edge with a non-existent node name, we\'ll get a compile-time error:\\n\\n```typescript\\n// This would cause a TypeScript error\\nticketSystem.addEdge(\\"receiveTicket\\", \\"nonExistentNode\\");\\n// Error: Argument of type \'\\"nonExistentNode\\"\' is not assignable to parameter of type \'\\"receiveTicket\\" | \\"processTicket\\" | \\"closeTicket\\"\'.\\n```\\n\\nThis type safety extends to other methods that use node names, such as `addConditionalEdges`:\\n\\n```typescript\\nticketSystem.addConditionalEdges(\\n\\"processTicket\\",\\n(state) => state.currentTicket.status === \\"in_progress\\" ? \\"closeTicket\\" : \\"receiveTicket\\",\\n[\\"closeTicket\\", \\"receiveTicket\\"]\\n);\\n```\\n\\nIn this case, TypeScript will ensure that:\\n1. \\"processTicket\\" is a valid node name for the first argument.\\n2. The function returns a valid node name.\\n3. The array in the third argument only contains valid node names.\\n\\n## 5. Compiling and Running the StateGraph\\n\\nFinally, when we compile our graph:\\n\\n```typescript\\nconst compiledGraph = ticketSystem.compile();\\n```\\n\\nThe type of `compiledGraph` is:\\n\\n```typescript\\nconst compiledGraph: CompiledStateGraph<\\nStateType<typeof TicketSystemState>,\\nUpdateType<typeof TicketSystemState>,\\n\\"receiveTicket\\" | \\"processTicket\\" | \\"closeTicket\\",\\ntypeof TicketSystemState,\\ntypeof TicketSystemState\\n>;\\n```\\n\\nThis compiled graph is what we actually use to run our workflow:\\n\\n```typescript\\nconst result = await compiledGraph.invoke({});\\n// result is of type StateType<typeof TicketSystemState>\\n```"},{"id":"todo-with-more-features","metadata":{"permalink":"/blog/todo-with-more-features","source":"@site/blog/2024-08-14-todo-with-more-features.mdx","title":"Todo with more features","description":"The previous app was too easy for all the models, so I iterated on the prompt until I came up with a more detailed prompt.","date":"2024-08-14T00:00:00.000Z","tags":[],"readingTime":1.045,"hasTruncateMarker":true,"authors":[{"name":"Gareth Andrew","title":"Chief Auto Coder","url":"https://github.com/autocode2","imageURL":"https://github.com/autocode2.png","key":"gingerhendrix","page":null}],"frontMatter":{"slug":"todo-with-more-features","title":"Todo with more features","authors":["gingerhendrix"],"tags":[]},"unlisted":false,"prevItem":{"title":"Understanding LangGraph Types","permalink":"/blog/understanding-langgraph-types"},"nextItem":{"title":"The React Todo App","permalink":"/blog/introducing-react-todo"}},"content":"The previous app was too easy for all the models, so I iterated on the prompt until I came up with a more detailed prompt.\\n\\n\x3c!-- truncate --\x3e\\n\\n```markdown title=\\"App Prompt\\"\\nBuild a todo app.\\n\\nEach todo item should have the following properties:\\n- content\\n- status (todo, in progress, complete)\\n- due date (optional)\\n- created date, started date (when it was marked as in progress), completed date (when it was marked as complete)\\n- tags (optional)\\n- priority (optional)\\n\\nThe app should have the following features:\\n - You should be able to see the list of todos.\\n - You should be able to add a todo, delete a todo and update a todo.\\n - You should be able to mark a todo as complete.\\n - You should be able to filter the todos by tags, status, priority, due date, including combinations of these filters.\\n - You should be able to sort the todos by due date, created date, started date, completed date, priority, status.\\n - You should be able to search for a todo by content.\\n```\\n\\nClaude-3-5-sonnet mostly doesn\'t break a sweat, though we do have to fix a type error to get a production build.\\n\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-14-todo-with-more-features/typescript_nextjs_shadcn/sonnet)\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/0057b0233f4042afebd4de82838a7d61552d13e1)\\n* [Manual Fix](https://github.com/autocode2/example-todo/commit/66300288caa28d190f76976ff7fa636d415985d1)"},{"id":"introducing-react-todo","metadata":{"permalink":"/blog/introducing-react-todo","source":"@site/blog/2024-08-01-introducing-react-todo.mdx","title":"The React Todo App","description":"Todo apps are a classic example app, here we\'ll see how a few models fare when trying to implement one in React.","date":"2024-08-01T00:00:00.000Z","tags":[],"readingTime":2.685,"hasTruncateMarker":true,"authors":[{"name":"Gareth Andrew","title":"Chief Auto Coder","url":"https://github.com/autocode2","imageURL":"https://github.com/autocode2.png","key":"gingerhendrix","page":null}],"frontMatter":{"slug":"introducing-react-todo","title":"The React Todo App","authors":["gingerhendrix"],"tags":[]},"unlisted":false,"prevItem":{"title":"Todo with more features","permalink":"/blog/todo-with-more-features"},"nextItem":{"title":"The Rise of Automatic Coding","permalink":"/blog/the-rise-of-automatic-coding"}},"content":"Todo apps are a classic example app, here we\'ll see how a few models fare when trying to implement one in React.\\n\\n\x3c!-- truncate --\x3e\\n\\nThe models we\'re going to use are:\\n* haiku (claude-3-haiku-20240307)\\n* sonnet (claude-3-5-sonnet-20240620)\\n* gpt-4o (gpt-4o-2024-05-13)\\n* gpt-4o-mini (gpt-4o-mini-2024-07-18)\\n\\nWe\'re going to run them through 3 initial scenarios:\\n- Generate a working app from scratch\\n- Generate a working app from a basic template - create-vite-app\\n- Generate a working app from with a stack of typescript, nextjs and tailwindcss.\\n\\n## Prompts\\n\\nThe setup is purposefully simple for this test. We\'ve configured an agent with `create-file`, `replace-file`, and `delete-file` tools and the following tprompt.\\n\\n### Prompts and Model Setup\\n\\n```markdown title=\\"System Prompt\\"\\nYou are an AI coding tool. Help the user with their coding tasks using the tools provided.\\n\\nYou will be given information about the current project in a <Context></Context> element.  This will include the full contents of files in the project, using <File></File> elements.\\n\\nUse the tools to perform the task. Ensure that the content of files is complete and will run as-is.  Do not leave any placeholders or elide the code. Guess sensible defaults if required.\\n\\nYou may call multiple tools in a single response.  You may also call the same tool multiple times. Call all the necessary tools to complete the users request.\\n```\\n\\n### The App Prompt\\n\\n```markdown title=\\"The Prompt\\"\\nBuild a simple react app which a simple todo app.\\n - You should be able to add a todo, delete a todo and update a todo.\\n - You should be able to see a list of todos.\\n - You should be able to mark a todo as complete.\\n - You should be able to filter the todos by complete and incomplete.\\n - You should be able to see the count of complete and incomplete\\n```\\n\\n## Working from scratch\\n\\nFor this test we add the following line to the prompt:\\n\\n```markdown\\nGenerate an index.html and a src/App.js that will run in a browser without any further steps.\\n```\\n### haiku\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/ff728811501645e92030f5b35d43bf75d9a8c0c2)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/no_context/fixed_haiku/)\\n\\nhaiku doesn\'t quite create runnable code.  The `import` statement for react won\'t work without further configuration, but [after a quick fix](https://github.com/autocode2/example-todo/commit/413546131cf8a736d12003cf017465009b2469b4) the app is usable and satisfies all the requirements but it\'s very ugly.\\n\\n### sonnet\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/83687116cc636f52910ee600eb99963a9bbeb8fe)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/no_context/sonnet/)\\n\\n### gpt-4o\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/557c13ad910fb39a50cdd4c4ab5f513769ccbd14)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/no_context/gpt-4o/)\\n\\n### gpt-4o-mini\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/b1f74c6a0a0105b0151a88ef0de93b47b58a454f)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/no_context/gpt-4o-mini/)\\n\\n## Create Vite App\\n\\n### haiku\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/28b86896d92d930f5012eb4a1965f2c513466c8c)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/vite_app/haiku)\\n\\n### sonnet\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/010ece34bad7102178657048a0214094cf6a3c7b)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/vite_app/sonnet)\\n\\n### gpt-4o-mini\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/809649c47a2b6cf861a38ecb2909b598141a4d4f)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/vite_app/gpt-4o-mini)\\n\\n### gpt-4o\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/e59f03e21bf7b01e50f1891b82553c0e8c6cc6f7)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/vite_app/gpt-4o)\\n\\n## NextJS, Typescript and TailwindCSS\\n\\n\\n### haiku\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/9db7ce4769cc0a83f8d240e3d8ce0821a7352c3b)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/typescript_nextjs_shadcn/haiku_use_client_prompt)\\n\\nHaiku initially failed to generate a working app, as it was missing the `\'use client\'` directive from NextJS 13+.\\nAdding the following line to the prompt fixed the issue:\\n```markdown\\nNote. This is a Nextjs 13+ project, so make sure to use the \'use client\' directive appropriately.\\n```\\n\\n### sonnet\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/42a36d5dd5c064ad0b7af480d4d6f4c70ae0e715)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/typescript_nextjs_shadcn/sonnet)\\n\\n### gpt-4o-mini\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/3538b78e22f4213ebf1721138597851a967f11ae)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/typescript_nextjs_shadcn/gpt-4o-mini)\\n\\n### gpt-4o\\n\\n* [Generated Code](https://github.com/autocode2/example-todo/commit/a9c387fd1aa244532dd568e77c94cfabf4529372)\\n* [View the App](https://autocode2.github.io/autocode-examples/examples/example-todo/blog/2024-08-01-introducing-react-todo/typescript_nextjs_shadcn/gpt-4o)"},{"id":"the-rise-of-automatic-coding","metadata":{"permalink":"/blog/the-rise-of-automatic-coding","source":"@site/blog/2024-07-18-automatic-coding.mdx","title":"The Rise of Automatic Coding","description":"It\'s pretty clear to anyone paying attention: LLMs can code. This fact is changing how we think about software development.","date":"2024-07-18T00:00:00.000Z","tags":[{"inline":false,"label":"futurology","permalink":"/blog/tags/futurology","description":"prognostications on the future"}],"readingTime":0.94,"hasTruncateMarker":true,"authors":[{"name":"Gareth Andrew","title":"Chief Auto Coder","url":"https://github.com/autocode2","imageURL":"https://github.com/autocode2.png","key":"gingerhendrix","page":null}],"frontMatter":{"slug":"the-rise-of-automatic-coding","title":"The Rise of Automatic Coding","authors":["gingerhendrix"],"tags":["futurology"]},"unlisted":false,"prevItem":{"title":"The React Todo App","permalink":"/blog/introducing-react-todo"}},"content":"It\'s pretty clear to anyone paying attention: LLMs can code. This fact is changing how we think about software development.\\n\\n\x3c!-- truncate --\x3e\\n\\nIn the auto-code project, I\'m exploring just how far we can push LLM coding abilities. I\'ve noticed two main ways AI is being used for coding:\\n\\n1. AI-Assisted Coding: This is where professional developers are heading. Tools like GitHub Copilot, and fancier ones like Cursor and Devin are becoming part of a coder\'s daily life. Even if AI ends up writing most of the code, the human is still in charge.\\n\\n2. Automated Code Generation: This is for everybody, being able to describe a tool, or an app, or a game and have it built for you is immensely useful.  It won\'t replace professionally developed software but it\'s undoubtedly going to be a huge trend in the future (no-code/low-code was already a fast growing sector before it had AI-boosters)\\n\\nThrough this project, I\'m trying to figure out what AI can and can\'t do when it comes to coding. It\'s pretty exciting to think about where this might lead us in the world of software creation."}]}}')}}]);