"use strict";(self.webpackChunkautocode_2_github_io=self.webpackChunkautocode_2_github_io||[]).push([[6202],{4783:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var i=n(4848),s=n(8453);const a={slug:"understanding-langgraph-types",title:"Understanding LangGraph Types",authors:["gingerhendrix"],tags:[]},r=void 0,c={permalink:"/blog/understanding-langgraph-types",source:"@site/blog/2024-10-15-understanding-langgraph-types.mdx",title:"Understanding LangGraph Types",description:"I often run into difficulties trying to build generic apis on top of LangGraph. The types are quite complex so I needed a reference.",date:"2024-10-15T00:00:00.000Z",tags:[],readingTime:4.95,hasTruncateMarker:!0,authors:[{name:"Gareth Andrew",title:"Chief Auto Coder",url:"https://github.com/autocode2",imageURL:"https://github.com/autocode2.png",key:"gingerhendrix",page:null}],frontMatter:{slug:"understanding-langgraph-types",title:"Understanding LangGraph Types",authors:["gingerhendrix"],tags:[]},unlisted:!1,prevItem:{title:"Testing the new Sonnet",permalink:"/blog/new-sonnet"},nextItem:{title:"Todo with more features",permalink:"/blog/todo-with-more-features"}},o={authorsImageUrls:[void 0]},d=[{value:"1. StateDefinition and Channels: The Building Blocks of State",id:"1-statedefinition-and-channels-the-building-blocks-of-state",level:2},{value:"2. Annotation.Root: Syntactic Sugar for State Definition",id:"2-annotationroot-syntactic-sugar-for-state-definition",level:2},{value:"3. Building a StateGraph: Understanding the State Types",id:"3-building-a-stategraph-understanding-the-state-types",level:2},{value:"4. Type-Safe Node Names in StateGraph",id:"4-type-safe-node-names-in-stategraph",level:2},{value:"5. Compiling and Running the StateGraph",id:"5-compiling-and-running-the-stategraph",level:2}];function l(e){const t={code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"I often run into difficulties trying to build generic apis on top of LangGraph. The types are quite complex so I needed a reference."}),"\n",(0,i.jsx)(t.h2,{id:"1-statedefinition-and-channels-the-building-blocks-of-state",children:"1. StateDefinition and Channels: The Building Blocks of State"}),"\n",(0,i.jsxs)(t.p,{children:["At the heart of LangGraph's state management is the ",(0,i.jsx)(t.code,{children:"StateDefinition"}),". This is an object that defines the structure of your application's state, where each key represents a piece of state, and the value is a ",(0,i.jsx)(t.em,{children:"channel"})," that determines how that state is\nupdated."]}),"\n",(0,i.jsxs)(t.p,{children:["A channel in LangGraph is an instance of a class that extends ",(0,i.jsx)(t.code,{children:"BaseChannel"}),". Different channel types provide different behaviors for updating state. Let's look at some common channel types:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"import { LastValue, Topic, BinaryOperatorAggregate, EphemeralValue } from \"@langchain/langgraph/channels\";\n\n// Define our state structure\ninterface Ticket {\n    id: string;\n    customer: string;\n    issue: string;\n    status: 'open' | 'in_progress' | 'closed';\n}\n\n// Create our state definition with explicit channels\nconst TicketSystemState = {\n    currentTicket: new LastValue<Ticket>(),\n    allTickets: new Topic<Ticket>({ accumulate: true }),\n    ticketCounts: new BinaryOperatorAggregate<Record<Ticket['status'], number>, Ticket>(\n      (current, newTicket) => ({\n        ...current,\n        [newTicket.status]: (current[newTicket.status] || 0) + 1,\n      }),\n      () => ({ open: 0, in_progress: 0, closed: 0 })\n    ),\n    lastAction: new LastValue<string>(),\n    tempData: new EphemeralValue<any>(),\n};\n"})}),"\n",(0,i.jsx)(t.p,{children:"In this example:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"LastValue"})," always stores the most recent value."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Topic"})," accumulates values over time."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"BinaryOperatorAggregate"})," allows custom reduction logic."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"EphemeralValue"})," stores temporary data that's cleared after each step."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Each channel type provides different behavior for how state is updated and maintained throughout the execution of your graph."}),"\n",(0,i.jsx)(t.h2,{id:"2-annotationroot-syntactic-sugar-for-state-definition",children:"2. Annotation.Root: Syntactic Sugar for State Definition"}),"\n",(0,i.jsxs)(t.p,{children:["While explicitly defining channels gives you fine-grained control, LangGraph provides a more concise way to define state using ",(0,i.jsx)(t.code,{children:"Annotation.Root"}),". This approach uses type inference and default behaviors to simplify your state definition:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"import { Annotation } from \"@langchain/langgraph\";\n\nconst TicketSystemState = Annotation.Root({\n    currentTicket: Annotation<Ticket>(),\n    allTickets: Annotation<Ticket[]>({\n      reducer: (current, newTickets) => [...current, ...newTickets],\n      default: () => [],\n    }),\n    ticketCounts: Annotation<Record<Ticket['status'], number>>({\n      reducer: (current, newTicket: Ticket) => ({\n        ...current,\n        [newTicket.status]: (current[newTicket.status] || 0) + 1,\n      }),\n      default: () => ({ open: 0, in_progress: 0, closed: 0 }),\n    }),\n    lastAction: Annotation<string>(),\n    tempData: Annotation<any>(),\n});\n"})}),"\n",(0,i.jsx)(t.p,{children:"This approach is more concise and easier to read."}),"\n",(0,i.jsx)(t.h2,{id:"3-building-a-stategraph-understanding-the-state-types",children:"3. Building a StateGraph: Understanding the State Types"}),"\n",(0,i.jsx)(t.p,{children:"Let's create a StateGraph using our TicketSystemState and examine its type:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'import { StateGraph, type StateType, type UpdateType } from "@langchain/langgraph";\n\nconst ticketSystem = new StateGraph(TicketSystemState);\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The type of ",(0,i.jsx)(t.code,{children:"ticketSystem"})," is quite complex due to TypeScript's type inference. If we were to write it out explicitly, it would look something like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const ticketSystem: StateGraph<\ntypeof TicketSystemState,\nStateType<typeof TicketSystemState>,\nUpdateType<typeof TicketSystemState>,\nstring,\ntypeof TicketSystemState,\ntypeof TicketSystemState\n>;\n"})}),"\n",(0,i.jsx)(t.p,{children:"Let's break down these type parameters:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"typeof TicketSystemState"}),": This is the state definition."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"StateType<typeof TicketSystemState>"}),": This represents the actual state shape, derived from the state definition."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"UpdateType<typeof TicketSystemState>"}),": This represents the shape of partial updates to the state."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"string"}),": This is the default type for node names."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"typeof TicketSystemState"}),": This is used for both the input and output state definitions, which are the same as our main state in this case."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Now, when we add nodes to our StateGraph, the types of the state and updates are inferred from our state definition:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'ticketSystem.addNode("receiveTicket", (state) => {\n// \'state\' is inferred to be StateType<typeof TicketSystemState>\nconst newTicket: Ticket = {\n  id: `ticket_${Date.now()}`,\n  customer: "John Doe",\n  issue: "Cannot login",\n  status: "open",\n};\n// The return type is inferred to be UpdateType<typeof TicketSystemState>\nreturn {\n  currentTicket: newTicket,\n  allTickets: [newTicket],\n  ticketCounts: newTicket,\n  lastAction: "Received new ticket",\n  tempData: { receivedAt: new Date() },\n};\n});\n'})}),"\n",(0,i.jsx)(t.p,{children:"In this node function:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"state"})," parameter is of type ",(0,i.jsx)(t.code,{children:"StateType<typeof TicketSystemState>"}),", which includes all the fields we defined in our state."]}),"\n",(0,i.jsxs)(t.li,{children:["The return value is of type ",(0,i.jsx)(t.code,{children:"UpdateType<typeof TicketSystemState>"}),", which is a partial update to our state."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"4-type-safe-node-names-in-stategraph",children:"4. Type-Safe Node Names in StateGraph"}),"\n",(0,i.jsx)(t.p,{children:"In addition to type-checking the state, StateGraph also provides type safety for node names. As we add nodes to our graph, TypeScript updates the union type of node names in the StateGraph type. Let's see how this works:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'ticketSystem\n.addNode("receiveTicket", (state) => {\n  // Node logic here...\n  return { /* ... */ };\n})\n.addNode("processTicket", (state) => {\n  // Node logic here...\n  return { /* ... */ };\n})\n.addNode("closeTicket", (state) => {\n  // Node logic here...\n  return { /* ... */ };\n});\n'})}),"\n",(0,i.jsxs)(t.p,{children:["After adding these nodes, the type of ",(0,i.jsx)(t.code,{children:"ticketSystem"}),' includes the literal types "receiveTicket", "processTicket", and "closeTicket" in its node name union. The full type now looks like this:']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'const ticketSystem: StateGraph<\ntypeof TicketSystemState,\nStateType<typeof TicketSystemState>,\nUpdateType<typeof TicketSystemState>,\n"receiveTicket" | "processTicket" | "closeTicket",\ntypeof TicketSystemState,\ntypeof TicketSystemState\n>;\n'})}),"\n",(0,i.jsx)(t.p,{children:"This type-checking becomes particularly useful when we add edges:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'ticketSystem\n.addEdge("receiveTicket", "processTicket")\n.addEdge("processTicket", "closeTicket");\n'})}),"\n",(0,i.jsx)(t.p,{children:"TypeScript will ensure that we're only using node names that we've actually defined. If we try to add an edge with a non-existent node name, we'll get a compile-time error:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// This would cause a TypeScript error\nticketSystem.addEdge("receiveTicket", "nonExistentNode");\n// Error: Argument of type \'"nonExistentNode"\' is not assignable to parameter of type \'"receiveTicket" | "processTicket" | "closeTicket"\'.\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This type safety extends to other methods that use node names, such as ",(0,i.jsx)(t.code,{children:"addConditionalEdges"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'ticketSystem.addConditionalEdges(\n"processTicket",\n(state) => state.currentTicket.status === "in_progress" ? "closeTicket" : "receiveTicket",\n["closeTicket", "receiveTicket"]\n);\n'})}),"\n",(0,i.jsx)(t.p,{children:"In this case, TypeScript will ensure that:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:'"processTicket" is a valid node name for the first argument.'}),"\n",(0,i.jsx)(t.li,{children:"The function returns a valid node name."}),"\n",(0,i.jsx)(t.li,{children:"The array in the third argument only contains valid node names."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"5-compiling-and-running-the-stategraph",children:"5. Compiling and Running the StateGraph"}),"\n",(0,i.jsx)(t.p,{children:"Finally, when we compile our graph:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const compiledGraph = ticketSystem.compile();\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The type of ",(0,i.jsx)(t.code,{children:"compiledGraph"})," is:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'const compiledGraph: CompiledStateGraph<\nStateType<typeof TicketSystemState>,\nUpdateType<typeof TicketSystemState>,\n"receiveTicket" | "processTicket" | "closeTicket",\ntypeof TicketSystemState,\ntypeof TicketSystemState\n>;\n'})}),"\n",(0,i.jsx)(t.p,{children:"This compiled graph is what we actually use to run our workflow:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const result = await compiledGraph.invoke({});\n// result is of type StateType<typeof TicketSystemState>\n"})})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var i=n(6540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);